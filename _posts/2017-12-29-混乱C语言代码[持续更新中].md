---
layout: post
title: 混乱C语言代码
tag: [IOCCC]
category: [实用]
stickie: true
intro: 混乱的C语言代码～ 持续更新中...
---

没有加号的加法
---
大意就是让你只用位运算符号完成两个数的相加.

看到题目以后觉得很神奇,位运算还能实现加法？想了1个小时吧，只想到按位模拟：

```cpp
/* --- ans是当前数位，k是要进的位 --- */
int Sum(int a,int b,int k=0){
	int ans=1&(a^b^k);
	if(!(a|b))return ans;
	k&=(a|b);k|=a&b;
	return ans|(Sumb(a>>1,b>>1,k)<<1);
}
```

后来发现按位模拟很慢，于是又想了一会，终于改成了非递归版本的
好像与网上的大同小异...

```cpp
/* --- k=a&b判断哪些位置要进位，a^=b相当于不进位的加法 --- */
int Sum(int a,int b){
	for(int k=0;b;b=k<<1)
		k=a&b,a^=b;
	return a;
}
```

测试一下运行速度～

（测试用代码）
```cpp
#include<bits/stdc++.h>
#define CPS CLOCKS_PER_SEC
using namespace std;

const int maxn=1e8;
time_t st,hx,hy,hz;

int Suma(int a,int b){
	for(int k=0;b;b=k<<1)
		k=a&b,a^=b;
	return a;
}

int Sumb(int a,int b,int k=0){
	int ans=1&(a^b^k);
	if(!(a|b))return ans;
	k&=(a|b);k|=a&b;
	return ans|(Sumb(a>>1,b>>1,k)<<1);
}

int Sumc(int a,int b){
	return a+b;
}

int main( ){
	int m,n,j,k,i;
	/*scanf("%d%d",&n,&m);*/
	st=clock();
	for(i=1;i<=maxn;i++)Suma(maxn,maxn);
	hx=clock();
	for(i=1;i<=maxn;i++)Sumb(maxn,maxn);
	hy=clock();
	for(i=1;i<=maxn;i++)Sumc(maxn,maxn);
	hz=clock();
	printf("Suma: %lf\nSumb: %lf\nSumc: %lf\n",(double)(hx-st)/CPS,(double)(hy-hx)/CPS,(double(hz-hy)/CPS));
	return 0;
}

```
（运行结果 /s）
Suma: 0.648527
Sumb: 23.883048
Sumc: 0.238518

看来C自带的+号还是快很多...

输出自己本身的程序
---

思路来自于Ken Thompson
他的C程序是这样的

```c
char*s="char*s=%c%s%c;main(){printf(s,34,s,34);}"; main(){printf(s,34,s,34);}
```

C++版本是这样的：

```cpp
#include<cstdio>
int main( ){
	char *c="#include<cstdio>%cint main( ){%c    char *c=%c%s%c;%c    printf(c,10,10,34,c,34,10,10);%c}";
	printf(c,10,10,34,c,34,10,10);
}
```

不定快速读入
---

一直搞不懂scanf是怎么实现参数数目不定的函数的
直到我知道了这个东西

```cpp
void sum(char* a,...){}
```

...很奇怪是吧？于是我翻网上的博客才搞懂
我们需要这样几个过程
```cpp
首先定义ap字符串
1.获取一个变量之后的变量的地址
	#define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
2.获取字符串*a的下一个参数的地址
	#define va_start(ap,v) (ap = (va_list)&v + _INTSIZEOF(v) )
3.获取某个变量的下一个参数
	#define va_arg(ap,t) (*(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
4.清空ap字符串
	#define va_end(ap) (ap = (va_list)0)
5.判断是否结束（需要对*a做处理）
```
于是我码出了下面的代码（头文件不能打多了，不然会与自带的va_冲突）
```cpp
/* --- Free-read～～～ --- */
#include<iostream>
#include<string.h>
#include<algorithm>
using namespace std;

typedef char* va_list;
typedef int tp;
#define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
#define va_start(ap,v) (ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t) (*(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) (ap = (va_list)0)
#define isfinal(Ch) if(Ch==EOF)return 0;else if(Ch=='-')Base=-1;

bool __read(int& Value){
	int Base=1;Value=0;char Ch=getchar();
	for(;!isdigit(Ch);Ch=getchar())isfinal(Ch);
	for(;isdigit(Ch);Ch=getchar())Value=Value*10+(Ch^'0');
	Value*=Base;return 1;
}

int _check__format(const char* fp){
	int sum=0;
	for(int i=0;i<strlen(fp);i++){
		if(!isdigit(fp[i]))return 0;
		sum=sum*10+fp[i]-'0';
	}
	return sum;
}

int Fread(const char* Num,...){
	va_list ap;
	if(!_check__format(Num))return 0;
	va_start(ap,Num);int tot=0;
	for(int i=0;i<_check__format(Num);i++){
		int *q=(int*)va_arg(ap,int);
		tot+=__read(*q);
	}
	va_end(ap);
	return tot;
}

int a,b,c,d;

int main( ){
	cout<<Fread("2",&a,&b)<<endl;;
	cout<<a<<" "<<b<<" "<<c<<endl;
}
```
